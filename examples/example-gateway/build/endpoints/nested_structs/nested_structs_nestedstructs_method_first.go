// Code generated by zanzibar
// @generated

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package nestedStructs

import (
	"context"

	"github.com/uber/zanzibar/examples/example-gateway/build/clients"
	zanzibar "github.com/uber/zanzibar/runtime"
	"go.uber.org/zap"

	clientsNestedStructsNestedStructs "github.com/uber/zanzibar/examples/example-gateway/build/gen-code/clients/nested_structs/nested_structs"
	endpointsNestedStructsNestedStructs "github.com/uber/zanzibar/examples/example-gateway/build/gen-code/endpoints/nested_structs/nested_structs"
)

// FirstHandler is the handler for "/first"
type FirstHandler struct {
	Clients *clients.Clients
}

// NewFirstEndpoint creates a handler
func NewFirstEndpoint(
	gateway *zanzibar.Gateway,
) *FirstHandler {
	return &FirstHandler{
		Clients: gateway.Clients.(*clients.Clients),
	}
}

// HandleRequest handles "/first".
func (handler *FirstHandler) HandleRequest(
	ctx context.Context,
	req *zanzibar.ServerHTTPRequest,
	res *zanzibar.ServerHTTPResponse,
) {
	var requestBody endpointsNestedStructsNestedStructs.NestedStructs_First_Args
	if ok := req.ReadAndUnmarshalBody(&requestBody); !ok {
		return
	}

	workflow := FirstEndpoint{
		Clients: handler.Clients,
		Logger:  req.Logger,
		Request: req,
	}

	response, cliRespHeaders, err := workflow.Handle(ctx, req.Header, &requestBody)
	if err != nil {
		switch errValue := err.(type) {

		default:
			req.Logger.Warn("Workflow for endpoint returned error",
				zap.String("error", errValue.Error()),
			)
			res.SendErrorString(500, "Unexpected server error")
			return
		}
	}

	res.WriteJSON(200, cliRespHeaders, response)
}

// FirstEndpoint calls thrift client NestedStructs.First
type FirstEndpoint struct {
	Clients *clients.Clients
	Logger  *zap.Logger
	Request *zanzibar.ServerHTTPRequest
}

// Handle calls thrift client.
func (w FirstEndpoint) Handle(
	ctx context.Context,
	reqHeaders zanzibar.Header,
	r *endpointsNestedStructsNestedStructs.NestedStructs_First_Args,
) (*endpointsNestedStructsNestedStructs.RequiredStruct, zanzibar.Header, error) {
	clientRequest := convertToFirstClientRequest(r)

	clientHeaders := map[string]string{}

	clientRespBody, _, err := w.Clients.NestedStructs.First(
		ctx, clientHeaders, clientRequest,
	)

	if err != nil {
		switch errValue := err.(type) {

		default:
			w.Logger.Warn("Could not make client request",
				zap.String("error", errValue.Error()),
			)
			// TODO(sindelar): Consider returning partial headers

			return nil, nil, err

		}
	}

	// Filter and map response headers from client to server response.

	// TODO: Add support for TChannel Headers with a switch here
	resHeaders := zanzibar.ServerHTTPHeader{}

	response := convertFirstClientResponse(clientRespBody)
	return response, resHeaders, nil
}

func convertToFirstClientRequest(in *endpointsNestedStructsNestedStructs.NestedStructs_First_Args) *clientsNestedStructsNestedStructs.NestedStructs_First_Args {
	out := &clientsNestedStructsNestedStructs.NestedStructs_First_Args{}

	out.One = bool(in.One)
	out.Two = int8(in.Two)
	out.Three = int16(in.Three)
	out.Four = int32(in.Four)
	out.Five = int64(in.Five)
	out.Six = float64(in.Six)
	out.Seven = []byte(in.Seven)
	out.Eight = string(in.Eight)
	if in.Nine != nil {
		out.Nine = &clientsNestedStructsNestedStructs.RequiredStruct{}
		out.Nine.One = bool(in.Nine.One)
		out.Nine.Two = int8(in.Nine.Two)
		out.Nine.Three = int16(in.Nine.Three)
		out.Nine.Four = int32(in.Nine.Four)
		out.Nine.Five = int64(in.Nine.Five)
		out.Nine.Six = float64(in.Nine.Six)
		out.Nine.Seven = []byte(in.Nine.Seven)
		out.Nine.Eight = string(in.Nine.Eight)
		if in.Nine.Nine != nil {
			out.Nine.Nine = &clientsNestedStructsNestedStructs.RequiredExtra{}
			out.Nine.Nine.One = make([]string, len(in.Nine.Nine.One))
			for index, value := range in.Nine.Nine.One {
				out.Nine.Nine.One[index] = string(value)
			}
			out.Nine.Nine.Two = make([]*clientsNestedStructsNestedStructs.OptionalTerminal, len(in.Nine.Nine.Two))
			for index, value := range in.Nine.Nine.Two {
				if value != nil {
					out.Nine.Nine.Two[index] = &clientsNestedStructsNestedStructs.OptionalTerminal{}
					out.Nine.Nine.Two[index].One = (*bool)(in.Nine.Nine.Two[index].One)
					out.Nine.Nine.Two[index].Two = (*int8)(in.Nine.Nine.Two[index].Two)
					out.Nine.Nine.Two[index].Three = (*int16)(in.Nine.Nine.Two[index].Three)
					out.Nine.Nine.Two[index].Four = (*int32)(in.Nine.Nine.Two[index].Four)
					out.Nine.Nine.Two[index].Five = (*int64)(in.Nine.Nine.Two[index].Five)
					out.Nine.Nine.Two[index].Six = (*float64)(in.Nine.Nine.Two[index].Six)
					out.Nine.Nine.Two[index].Seven = []byte(in.Nine.Nine.Two[index].Seven)
					out.Nine.Nine.Two[index].Eight = (*string)(in.Nine.Nine.Two[index].Eight)
				} else {
					out.Nine.Nine.Two[index] = nil
				}
			}
			out.Nine.Nine.Five = make(map[string]string, len(in.Nine.Nine.Five))
			for key, value := range in.Nine.Nine.Five {
				out.Nine.Nine.Five[key] = string(value)
			}
			out.Nine.Nine.Six = make(map[string]*clientsNestedStructsNestedStructs.OptionalTerminal, len(in.Nine.Nine.Six))
			for key, value := range in.Nine.Nine.Six {
				if value != nil {
					out.Nine.Nine.Six[key] = &clientsNestedStructsNestedStructs.OptionalTerminal{}
					out.Nine.Nine.Six[key].One = (*bool)(in.Nine.Nine.Six[key].One)
					out.Nine.Nine.Six[key].Two = (*int8)(in.Nine.Nine.Six[key].Two)
					out.Nine.Nine.Six[key].Three = (*int16)(in.Nine.Nine.Six[key].Three)
					out.Nine.Nine.Six[key].Four = (*int32)(in.Nine.Nine.Six[key].Four)
					out.Nine.Nine.Six[key].Five = (*int64)(in.Nine.Nine.Six[key].Five)
					out.Nine.Nine.Six[key].Six = (*float64)(in.Nine.Nine.Six[key].Six)
					out.Nine.Nine.Six[key].Seven = []byte(in.Nine.Nine.Six[key].Seven)
					out.Nine.Nine.Six[key].Eight = (*string)(in.Nine.Nine.Six[key].Eight)
				} else {
					out.Nine.Nine.Six[key] = nil
				}
			}
			out.Nine.Nine.Seven = clientsNestedStructsNestedStructs.UUID(in.Nine.Nine.Seven)
			out.Nine.Nine.Eight = clientsNestedStructsNestedStructs.ItemType(in.Nine.Nine.Eight)
			out.Nine.Nine.Nine = clientsNestedStructsNestedStructs.ItemState(in.Nine.Nine.Nine)
		} else {
			out.Nine.Nine = nil
		}
	} else {
		out.Nine = nil
	}

	return out
}

func convertFirstClientResponse(in *clientsNestedStructsNestedStructs.RequiredStruct) *endpointsNestedStructsNestedStructs.RequiredStruct {
	out := &endpointsNestedStructsNestedStructs.RequiredStruct{}

	out.One = bool(in.One)
	out.Two = int8(in.Two)
	out.Three = int16(in.Three)
	out.Four = int32(in.Four)
	out.Five = int64(in.Five)
	out.Six = float64(in.Six)
	out.Seven = []byte(in.Seven)
	out.Eight = string(in.Eight)
	if in.Nine != nil {
		out.Nine = &endpointsNestedStructsNestedStructs.RequiredExtra{}
		out.Nine.One = make([]string, len(in.Nine.One))
		for index, value := range in.Nine.One {
			out.Nine.One[index] = string(value)
		}
		out.Nine.Two = make([]*endpointsNestedStructsNestedStructs.OptionalTerminal, len(in.Nine.Two))
		for index, value := range in.Nine.Two {
			if value != nil {
				out.Nine.Two[index] = &endpointsNestedStructsNestedStructs.OptionalTerminal{}
				out.Nine.Two[index].One = (*bool)(in.Nine.Two[index].One)
				out.Nine.Two[index].Two = (*int8)(in.Nine.Two[index].Two)
				out.Nine.Two[index].Three = (*int16)(in.Nine.Two[index].Three)
				out.Nine.Two[index].Four = (*int32)(in.Nine.Two[index].Four)
				out.Nine.Two[index].Five = (*int64)(in.Nine.Two[index].Five)
				out.Nine.Two[index].Six = (*float64)(in.Nine.Two[index].Six)
				out.Nine.Two[index].Seven = []byte(in.Nine.Two[index].Seven)
				out.Nine.Two[index].Eight = (*string)(in.Nine.Two[index].Eight)
			} else {
				out.Nine.Two[index] = nil
			}
		}
		out.Nine.Five = make(map[string]string, len(in.Nine.Five))
		for key, value := range in.Nine.Five {
			out.Nine.Five[key] = string(value)
		}
		out.Nine.Six = make(map[string]*endpointsNestedStructsNestedStructs.OptionalTerminal, len(in.Nine.Six))
		for key, value := range in.Nine.Six {
			if value != nil {
				out.Nine.Six[key] = &endpointsNestedStructsNestedStructs.OptionalTerminal{}
				out.Nine.Six[key].One = (*bool)(in.Nine.Six[key].One)
				out.Nine.Six[key].Two = (*int8)(in.Nine.Six[key].Two)
				out.Nine.Six[key].Three = (*int16)(in.Nine.Six[key].Three)
				out.Nine.Six[key].Four = (*int32)(in.Nine.Six[key].Four)
				out.Nine.Six[key].Five = (*int64)(in.Nine.Six[key].Five)
				out.Nine.Six[key].Six = (*float64)(in.Nine.Six[key].Six)
				out.Nine.Six[key].Seven = []byte(in.Nine.Six[key].Seven)
				out.Nine.Six[key].Eight = (*string)(in.Nine.Six[key].Eight)
			} else {
				out.Nine.Six[key] = nil
			}
		}
		out.Nine.Seven = endpointsNestedStructsNestedStructs.UUID(in.Nine.Seven)
		out.Nine.Eight = endpointsNestedStructsNestedStructs.ItemType(in.Nine.Eight)
		out.Nine.Nine = endpointsNestedStructsNestedStructs.ItemState(in.Nine.Nine)
	} else {
		out.Nine = nil
	}

	return out
}
